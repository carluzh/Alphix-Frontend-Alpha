/**
 * Generate LP Transaction Steps
 *
 * COPIED FROM UNISWAP - DO NOT MODIFY WITHOUT UPDATING FROM SOURCE
 * Source: interface/packages/uniswap/src/features/transactions/liquidity/steps/generateLPTransactionSteps.ts
 *
 * This function generates the ordered transaction steps for liquidity operations
 * (create, increase, decrease, collect fees).
 */

import { CurrencyAmount, Token } from '@uniswap/sdk-core';

import {
  TransactionStepType,
  LiquidityTransactionType,
  type LiquidityTxAndGasInfo,
  type TransactionStep,
  isValidLiquidityTxContext,
} from '../../types';

import {
  createApprovalTransactionStep,
  createRevocationTransactionStep,
  createPermit2SignatureStep,
  createPermit2TransactionStep,
  createIncreasePositionStep,
  createIncreasePositionAsyncStep,
  createCreatePositionAsyncStep,
  createIncreasePositionStepBatched,
  createDecreasePositionStep,
  createCollectFeesStep,
  createUnifiedYieldApprovalStep,
  createUnifiedYieldDepositStep,
  createUnifiedYieldWithdrawStep,
  orderIncreaseLiquiditySteps,
  orderDecreaseLiquiditySteps,
  orderCollectFeesSteps,
  type IncreaseLiquidityFlow,
} from './steps';

import type { OnChainTransactionFields, IncreaseLiquiditySteps } from '../../types';

/**
 * Generates the ordered transaction steps for a liquidity operation.
 *
 * COPIED FROM UNISWAP - Logic matches interface/packages/uniswap/.../generateLPTransactionSteps.ts
 *
 * @param txContext - The validated liquidity transaction context
 * @returns An ordered array of transaction steps to execute
 */
export function generateLPTransactionSteps(txContext: LiquidityTxAndGasInfo): TransactionStep[] {
  // Handle Zap mode - steps are pre-generated by generateZapSteps
  const zapContext = txContext as any;
  if (zapContext.isZapMode && zapContext.zapSteps && Array.isArray(zapContext.zapSteps)) {
    console.log('[generateLPTransactionSteps] Using pre-generated zap steps:', zapContext.zapSteps.length);
    return zapContext.zapSteps as TransactionStep[];
  }

  const isValidLP = isValidLiquidityTxContext(txContext);

  if (!isValidLP) {
    console.error('[generateLPTransactionSteps] Invalid context:', {
      type: txContext?.type,
      hasAction: !!(txContext as any)?.action,
      hasTxRequest: !!(txContext as any)?.txRequest,
      hasPermit: !!(txContext as any)?.permit,
      unsigned: (txContext as any)?.unsigned,
      isUnifiedYield: (txContext as any)?.isUnifiedYield,
    });
  }

  if (isValidLP) {
    // Handle collect fees - simplest case, just the collect step
    if (txContext.type === LiquidityTransactionType.Collect) {
      return orderCollectFeesSteps({
        collectFees: createCollectFeesStep(txContext.txRequest),
      });
    }

    const {
      action,
      approveToken0Request,
      approveToken1Request,
      approvePositionTokenRequest,
      token0PermitTransaction,
      token1PermitTransaction,
    } = txContext;

    // Create revocation steps for each token
    const revokeToken0 = createRevocationTransactionStep(
      txContext.revokeToken0Request,
      action.currency0Amount.currency.wrapped as Token,
    );
    const revokeToken1 = createRevocationTransactionStep(
      txContext.revokeToken1Request,
      action.currency1Amount.currency.wrapped as Token,
    );

    // Create approval steps for each token
    const approvalToken0 = createApprovalTransactionStep({
      txRequest: approveToken0Request,
      amountIn: action.currency0Amount as unknown as CurrencyAmount<any>,
    });
    const approvalToken1 = createApprovalTransactionStep({
      txRequest: approveToken1Request,
      amountIn: action.currency1Amount as unknown as CurrencyAmount<any>,
    });
    const approvalPositionToken = createApprovalTransactionStep({
      txRequest: approvePositionTokenRequest,
      amountIn: action.liquidityToken
        ? CurrencyAmount.fromRawAmount(action.liquidityToken as Token, 1)
        : undefined,
      pair: [action.currency0Amount.currency, action.currency1Amount.currency] as [any, any],
    });

    // Create permit transaction steps
    const token0PermitTransactionStep = createPermit2TransactionStep({
      txRequest: token0PermitTransaction,
      amountIn: action.currency0Amount as unknown as CurrencyAmount<any>,
      pair: [action.currency0Amount.currency, action.currency1Amount.currency] as [any, any],
    });

    const token1PermitTransactionStep = createPermit2TransactionStep({
      txRequest: token1PermitTransaction,
      amountIn: action.currency1Amount as unknown as CurrencyAmount<any>,
      pair: [action.currency0Amount.currency, action.currency1Amount.currency] as [any, any],
    });

    switch (txContext.type) {
      case 'decrease':
        // Unified Yield withdrawals - direct Hook call, no approvals needed
        if (txContext.isUnifiedYield && txContext.hookAddress && txContext.sharesToWithdraw && txContext.txRequest) {
          return [
            createUnifiedYieldWithdrawStep(
              txContext.txRequest,
              txContext.hookAddress,
              txContext.poolId || '',
              txContext.sharesToWithdraw,
              action.currency0Amount.currency.symbol || '',
              action.currency1Amount.currency.symbol || '',
            ),
          ];
        }
        // V4 decrease - standard flow with position approval
        return orderDecreaseLiquiditySteps({
          approvalPositionToken,
          decreasePosition: createDecreasePositionStep(txContext.txRequest, txContext.sqrtRatioX96),
        });

      case 'create':
      case 'increase':
        // Unified Yield deposits - direct ERC20 approval to Hook, then deposit
        if (txContext.isUnifiedYield && txContext.hookAddress && txContext.sharesToMint && txContext.txRequest) {
          const steps: TransactionStep[] = [];

          // Add approval steps if needed (ERC20 approve to Hook, not Permit2)
          if (approveToken0Request) {
            steps.push(
              createUnifiedYieldApprovalStep(
                approveToken0Request,
                action.currency0Amount.currency.wrapped.address as `0x${string}`,
                action.currency0Amount.currency.symbol || '',
                txContext.hookAddress,
                BigInt(action.currency0Amount.quotient.toString()),
              ),
            );
          }
          if (approveToken1Request) {
            steps.push(
              createUnifiedYieldApprovalStep(
                approveToken1Request,
                action.currency1Amount.currency.wrapped.address as `0x${string}`,
                action.currency1Amount.currency.symbol || '',
                txContext.hookAddress,
                BigInt(action.currency1Amount.quotient.toString()),
              ),
            );
          }

          // Add deposit step
          steps.push(
            createUnifiedYieldDepositStep(
              txContext.txRequest,
              txContext.hookAddress,
              txContext.poolId || '',
              txContext.sharesToMint,
              action.currency0Amount.currency.symbol || '',
              action.currency1Amount.currency.symbol || '',
            ),
          );

          return steps;
        }

        // V4 create/increase flows below
        if (txContext.unsigned) {
          // Unsigned flow uses permit signature - MATCHES UNISWAP PATTERN
          // The async step will call the API with the signature to get the transaction
          return orderIncreaseLiquiditySteps({
            revokeToken0,
            revokeToken1,
            approvalToken0,
            approvalToken1,
            approvalPositionToken,
            permit: createPermit2SignatureStep(
              txContext.permit,
              action.currency0Amount.currency,
            ),
            token0PermitTransaction: undefined,
            token1PermitTransaction: undefined,
            increasePosition:
              txContext.type === 'increase'
                ? createIncreasePositionAsyncStep(txContext.increasePositionRequestArgs)
                : createCreatePositionAsyncStep(txContext.createPositionRequestArgs),
          });
        } else {
          // Signed flow uses permit transactions
          const steps = orderIncreaseLiquiditySteps({
            revokeToken0,
            revokeToken1,
            approvalToken0,
            approvalToken1,
            approvalPositionToken,
            permit: undefined,
            token0PermitTransaction: token0PermitTransactionStep,
            token1PermitTransaction: token1PermitTransactionStep,
            increasePosition: createIncreasePositionStep(txContext.txRequest, txContext.sqrtRatioX96),
          });

          // If batching is supported, combine all transactions into one batched step
          if (txContext.canBatchTransactions) {
            const txRequests = steps
              .filter((step): step is IncreaseLiquiditySteps & OnChainTransactionFields => 'txRequest' in step)
              .map((step) => step.txRequest);
            return [createIncreasePositionStepBatched(txRequests, txContext.sqrtRatioX96)];
          }

          return steps;
        }
    }
  }

  return [];
}
